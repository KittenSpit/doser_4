<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Doser</title>
<style>
  :root{
    --bd:#ddd; --bg:#fff; --fg:#111; --muted:#666; --btn:#f7f7f7; --ok:#126912; --err:#b00020;
  }
  @media (prefers-color-scheme: dark){
    :root{ --bd:#2b2b2b; --bg:#111; --fg:#eee; --muted:#aaa; --btn:#1d1d1d; --ok:#6bd36b; --err:#ff6b6b; }
    input, button { color-scheme: dark; }
  }
  html,body{background:var(--bg); color:var(--fg)}
  body{font-family:system-ui, Segoe UI, Arial, sans-serif; margin:16px; max-width:900px}
  .card{border:1px solid var(--bd); border-radius:12px; padding:12px; margin:12px 0}
  h2{margin:4px 0 8px}
  table{border-collapse:collapse; width:100%}
  td,th{border:1px solid var(--bd); padding:6px; text-align:left}
  button{padding:6px 10px; border-radius:8px; border:1px solid var(--bd); background:var(--btn); cursor:pointer}
  button[disabled]{opacity:.6; cursor:not-allowed}
  input[type=number]{width:7em}
  .row{display:flex; gap:12px; flex-wrap:wrap}
  pre{white-space:pre-wrap}
  .hint{color:var(--muted); font-size:.9em}
  .pill{display:inline-block; padding:2px 8px; border:1px solid var(--bd); border-radius:999px; font-size:.9em}
  .right{float:right}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
</style>

<div class="card"><h2>Status</h2>
  <div class="row">
    <span class="pill">Uptime: <span id="uptime">–</span></span>
    <span class="pill">Schedule: <span id="sched">off</span></span>
    <button class="right" id="refreshBtn">Refresh</button>
  </div>
  <pre id="st">loading&hellip;</pre>
</div>

<div class="card">
  <h2>Controls</h2>
  <div id="pumps"></div>
</div>

<div class="card">
  <h2>Settings</h2>
  <div id="sets"></div>
  <div class="row" style="margin-top:8px">
    <button id="saveBtn">Save</button>
    <span id="saveMsg" class="hint"></span>
  </div>
  <div class="hint">Tip: Set <span class="mono">Interval</span> to 0 to disable the scheduler.</div>
</div>

<div class="card">
  <h2>Logs</h2>
  <div class="row">
    <button id="logsBtn">Refresh</button>
    <a href="/logs.csv"><button type="button">Download CSV</button></a>
  </div>
  <pre id="logs" style="max-height:300px; overflow:auto"></pre>
</div>

<script>
// -------- Utilities --------
const $ = (sel, root=document) => root.querySelector(sel);
const el = (tag, props={}, ...children) => { const n = document.createElement(tag); Object.assign(n, props); for(const c of children){ n.append(c); } return n; };

function msFmt(ms){ if(ms == null) return "–"; let s = Math.floor(ms/1000); const h = Math.floor(s/3600); s%=3600; const m = Math.floor(s/60); s%=60; return (h? h+"h ":"") + (m? m+"m ":"") + s + "s"; }
function secsFmt(secs){ if(secs == null) return "–"; const s = Math.max(0, Math.floor(secs)); const h=Math.floor(s/3600), m=Math.floor((s%3600)/60), r=s%60; return (h? h+":" : "") + String(m).padStart(2,'0') + ":" + String(r).padStart(2,'0'); }

async function fetchJSON(url, opts={}, timeoutMs=8000){
  const ctrl = new AbortController(); const to = setTimeout(()=>ctrl.abort(), timeoutMs);
  try{ const res = await fetch(url, {...opts, signal: ctrl.signal}); if(!res.ok) throw new Error(res.status+" "+res.statusText);
    const ct = res.headers.get('content-type')||''; if(!ct.includes('application/json')){ try { return await res.json(); } catch(e){ throw new Error('Expected JSON'); } }
    return await res.json();
  } finally{ clearTimeout(to); }
}

// ===== Preserve unsaved edits across refresh/polling =====
// We keep a small in-memory cache of edits so render() won't clobber user input.
const edits = { sec:{}, mls:{}, duty:{}, ofs:{}, ival:null };
const getEdit = (group, idx, fallback) => {
  const g = edits[group];
  const v = (idx==null) ? g : g[idx];
  return (v!==undefined && v!==null && v!=='') ? v : fallback;
};
// Persist last-known offsets (and other settings) so they survive reloads even if backend doesn't return them
const LS_KEY = 'doser-ui-cache.v1';
function loadCache(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'{}'); }catch{ return {}; } }
function saveCache(obj){ try{ localStorage.setItem(LS_KEY, JSON.stringify(obj)); }catch{} }
let cache = loadCache();
const clearEdits = () => { edits.sec={}; edits.mls={}; edits.duty={}; /* keep edits.ofs until backend starts returning it */ /* edits.ival left as-is */ };

// Backoff for polling when device is offline
let pollInterval = 2000; function bumpBackoff(){ pollInterval = Math.min(pollInterval*1.6, 15000); } function resetBackoff(){ pollInterval = 2000; }

// -------- Rendering --------
async function getStatus(){ return fetchJSON('/api/status'); }

async function render(){
  try{
    const s = await getStatus(); resetBackoff();
    $('#st').textContent = JSON.stringify(s, null, 2);
    $('#uptime').textContent = msFmt(s.uptime_ms);
    const ivalServer = (s.schedule_interval_s ?? 0);
    $('#sched').textContent = ivalServer>0 ? (ivalServer+"s") : 'off';

    // Controls
    const div = $('#pumps'); div.innerHTML='';
    (s.pumps||[]).forEach(p=>{
      const status = p.running ? 'RUNNING' : 'IDLE';
      const nextTxt = (p.next_run_in_s!=null && p.next_run_in_s>=0) ? (secsFmt(p.next_run_in_s)) : '(disabled)';
      const row = el('div', {className:'card'});
      const title = el('div', {innerHTML: `<b>Pump ${p.idx}</b> &mdash; ${status} &mdash; next: ${nextTxt}`});
      const controls = el('div', {className:'row', style:'margin-top:6px'});
      const inp = el('input', {id:`sec${p.idx}`, type:'number', min:'1', value:String(getEdit('sec', p.idx, 3))});
      inp.addEventListener('input', e=>{ edits.sec[p.idx] = e.target.value; });
      const lab = el('label', {innerText:'Sec '}); lab.append(inp);
      const bPrime = el('button', {innerText:'Prime', onclick:()=>action('prime', p.idx)});
      const bPurge = el('button', {innerText:'Purge', onclick:()=>action('purge', p.idx)});
      const bStop  = el('button', {innerText:'Stop',  onclick:()=>action('stop', p.idx)});
      controls.append(lab, bPrime, bPurge, bStop);
      row.append(title, controls);
      div.append(row);
    });

    // Settings table
    const sets = $('#sets'); sets.innerHTML='';
    const t = el('table');
    t.append(el('tr',{}, el('th',{innerText:'Pump'}), el('th',{innerText:'mL/s'}), el('th',{innerText:'Duty (0-255)'}), el('th',{innerText:'Offset (s)'})));
    (s.pumps||[]).forEach(p=>{
      const tr = el('tr');
      const inMls = el('input',{id:`mls${p.idx}`, type:'number', step:'0.01', value:String(getEdit('mls', p.idx, p.ml_per_sec ?? 0))});
      inMls.addEventListener('input', e=>{ edits.mls[p.idx] = e.target.value; });
      const inDuty = el('input',{id:`duty${p.idx}`, type:'number', min:'0', max:'255', value:String(getEdit('duty', p.idx, p.duty ?? 0))});
      inDuty.addEventListener('input', e=>{ edits.duty[p.idx] = e.target.value; });
      const inOfs = el('input',{id:`ofs${p.idx}`, type:'number', min:'0', value:String(getEdit('ofs', p.idx, (p.offset_s ?? (cache.ofs?.[p.idx] ?? 0))))});
      inOfs.addEventListener('input', e=>{ edits.ofs[p.idx] = e.target.value; cache.ofs = cache.ofs || {}; cache.ofs[p.idx] = e.target.value; saveCache(cache); });

      tr.append(
        el('td',{innerText:String(p.idx)}),
        el('td',{}, inMls),
        el('td',{}, inDuty),
        el('td',{}, inOfs)
      );
      t.append(tr);
    });

    const tr2 = el('tr');
    const tdLabel = el('td',{}, el('b',{innerText:'Schedule'}));
    const tdInput = el('td',{colSpan:3});
    const inIval = el('input',{id:'ival', type:'number', min:'0', value:String(getEdit('ival', null, ivalServer))});
    inIval.addEventListener('input', e=>{ edits.ival = e.target.value; });
    tdInput.append('Interval (s): ', inIval, ' (0=off)');
    tr2.append(tdLabel, tdInput);
    t.append(tr2);

    sets.append(t);

  }catch(e){
    bumpBackoff();
    $('#st').textContent = 'Error loading status: '+ e.message;
  }
}

async function action(kind, i){
  try{
    const sec = +(document.getElementById('sec'+i)?.value||1);
    setButtonsDisabled(true);
    if(kind==='stop'){
      await fetch(`/api/stop?pump=${i}`);
    }else{
      await fetch(`/api/${kind}?pump=${i}&sec=${sec}`);
    }
  }catch(e){
    alert(kind+': '+e.message);
  }finally{
    setButtonsDisabled(false);
    render();
  }
}

function setButtonsDisabled(dis){
  document.querySelectorAll('button').forEach(b=>{
    if(b.id==='logsBtn' || b.id==='refreshBtn') return; // keep utility buttons clickable
    b.disabled = dis;
  });
}

async function save(){
  try{
    setButtonsDisabled(true);
    const s = await getStatus();
    const body = { schedule_interval_s: +(getEdit('ival', null, $('#ival').value||cache.ival||0) || 0), pumps: [] };
    (s.pumps||[]).forEach(p=>{
      body.pumps.push({
        idx: p.idx,
        ml_per_sec: +(getEdit('mls', p.idx, $('#mls'+p.idx).value || cache.mls?.[p.idx] || 0) || 0),
        duty: +(getEdit('duty', p.idx, $('#duty'+p.idx).value || cache.duty?.[p.idx] || 0) || 0),
        offset_s: +(getEdit('ofs', p.idx, $('#ofs'+p.idx).value || (cache.ofs?.[p.idx] ?? 0)) || 0)
      });
    });
    const res = await fetch('/api/settings', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
    $('#saveMsg').textContent = res.ok ? 'Saved.' : ('Error '+res.status);
    if(res.ok){ clearEdits(); /* keep cache so offset persists */ saveCache(cache); }
    if(!res.ok) throw new Error('Save failed');
  }catch(e){
    $('#saveMsg').textContent = 'Error: '+e.message;
  }finally{
    setTimeout(()=>$('#saveMsg').textContent='', 2500);
    setButtonsDisabled(false);
    render();
  }
}

async function reloadLogs(){
  try{
    const j = await fetchJSON('/logs.json');
    const txt = JSON.stringify(j,null,2);
    const pre = $('#logs');
    pre.textContent = txt;
    pre.scrollTop = pre.scrollHeight; // autoscroll to bottom
  }catch(e){
    $('#logs').textContent = 'Error loading logs: ' + e.message;
  }
}

// Polling loop with page-visibility awareness
let pollTimer = null; function scheduleNext(){ clearTimeout(pollTimer); pollTimer = setTimeout(async ()=>{ await render(); scheduleNext(); }, pollInterval); }

document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ clearTimeout(pollTimer); } else { resetBackoff(); render().then(scheduleNext); } });

// Wire up buttons
$('#saveBtn').addEventListener('click', save);
$('#logsBtn').addEventListener('click', reloadLogs);
$('#refreshBtn').addEventListener('click', ()=>{ render(); });

// Initial
render(); reloadLogs(); scheduleNext();
</script>
</html>
